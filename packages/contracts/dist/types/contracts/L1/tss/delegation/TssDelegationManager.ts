/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../../../common";

export declare namespace IDelegationManager {
  export type WithdrawerAndNonceStruct = {
    withdrawer: PromiseOrValue<string>;
    nonce: PromiseOrValue<BigNumberish>;
  };

  export type WithdrawerAndNonceStructOutput = [string, BigNumber] & {
    withdrawer: string;
    nonce: BigNumber;
  };

  export type QueuedWithdrawalStruct = {
    delegations: PromiseOrValue<string>[];
    tokens: PromiseOrValue<string>[];
    shares: PromiseOrValue<BigNumberish>[];
    depositor: PromiseOrValue<string>;
    withdrawerAndNonce: IDelegationManager.WithdrawerAndNonceStruct;
    delegatedAddress: PromiseOrValue<string>;
  };

  export type QueuedWithdrawalStructOutput = [
    string[],
    string[],
    BigNumber[],
    string,
    IDelegationManager.WithdrawerAndNonceStructOutput,
    string
  ] & {
    delegations: string[];
    tokens: string[];
    shares: BigNumber[];
    depositor: string;
    withdrawerAndNonce: IDelegationManager.WithdrawerAndNonceStructOutput;
    delegatedAddress: string;
  };
}

export interface TssDelegationManagerInterface extends utils.Interface {
  functions: {
    "DEPOSIT_TYPEHASH()": FunctionFragment;
    "DOMAIN_SEPARATOR()": FunctionFragment;
    "DOMAIN_TYPEHASH()": FunctionFragment;
    "REASONABLE_STAKES_UPDATE_PERIOD()": FunctionFragment;
    "WITHDRAWAL_WAITING_PERIOD()": FunctionFragment;
    "addToWhitelist(address[])": FunctionFragment;
    "calculateWithdrawalRoot((address[],address[],uint256[],address,(address,uint96),address))": FunctionFragment;
    "canCompleteQueuedWithdrawal((address[],address[],uint256[],address,(address,uint96),address))": FunctionFragment;
    "completeQueuedWithdrawal((address[],address[],uint256[],address,(address,uint96),address),bool)": FunctionFragment;
    "completeQueuedWithdrawal(address,(address[],address[],uint256[],address,(address,uint96),address),bool)": FunctionFragment;
    "delegation()": FunctionFragment;
    "delegationSlasher()": FunctionFragment;
    "depositInto(address,address,uint256,address)": FunctionFragment;
    "depositInto(address,address,uint256)": FunctionFragment;
    "getDelegationShares(address,address)": FunctionFragment;
    "getDeposits(address)": FunctionFragment;
    "getWithdrawNonce(address)": FunctionFragment;
    "initialize(address)": FunctionFragment;
    "initializeT(address,address,uint256,address)": FunctionFragment;
    "investorDelegationLength(address)": FunctionFragment;
    "investorDelegationShares(address,address)": FunctionFragment;
    "investorDelegations(address,uint256)": FunctionFragment;
    "isCanOperator(address,address)": FunctionFragment;
    "minStakeAmount()": FunctionFragment;
    "nonces(address)": FunctionFragment;
    "numWithdrawalsQueued(address)": FunctionFragment;
    "owner()": FunctionFragment;
    "paused()": FunctionFragment;
    "queueWithdrawal(address,uint256[],address[],address[],uint256[],(address,uint96))": FunctionFragment;
    "queueWithdrawal(uint256[],address[],address[],uint256[],(address,uint96),bool)": FunctionFragment;
    "queuedWithdrawals(bytes32)": FunctionFragment;
    "removeFromWhitelist(address[])": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "setMinStakeAmount(uint256)": FunctionFragment;
    "setStakingSlash(address)": FunctionFragment;
    "setTssGroupManager(address)": FunctionFragment;
    "slashQueuedWithdrawal(address,(address[],address[],uint256[],address,(address,uint96),address))": FunctionFragment;
    "slashShares(address,address,address[],address[],uint256[],uint256[])": FunctionFragment;
    "stakingSlash()": FunctionFragment;
    "startQueuedWithdrawalWaitingPeriod(bytes32,address,uint32)": FunctionFragment;
    "startQueuedWithdrawalWaitingPeriod(bytes32,uint32)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "tssGroupManager()": FunctionFragment;
    "undelegate()": FunctionFragment;
    "whitelist(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "DEPOSIT_TYPEHASH"
      | "DOMAIN_SEPARATOR"
      | "DOMAIN_TYPEHASH"
      | "REASONABLE_STAKES_UPDATE_PERIOD"
      | "WITHDRAWAL_WAITING_PERIOD"
      | "addToWhitelist"
      | "calculateWithdrawalRoot"
      | "canCompleteQueuedWithdrawal"
      | "completeQueuedWithdrawal((address[],address[],uint256[],address,(address,uint96),address),bool)"
      | "completeQueuedWithdrawal(address,(address[],address[],uint256[],address,(address,uint96),address),bool)"
      | "delegation"
      | "delegationSlasher"
      | "depositInto(address,address,uint256,address)"
      | "depositInto(address,address,uint256)"
      | "getDelegationShares"
      | "getDeposits"
      | "getWithdrawNonce"
      | "initialize"
      | "initializeT"
      | "investorDelegationLength"
      | "investorDelegationShares"
      | "investorDelegations"
      | "isCanOperator"
      | "minStakeAmount"
      | "nonces"
      | "numWithdrawalsQueued"
      | "owner"
      | "paused"
      | "queueWithdrawal(address,uint256[],address[],address[],uint256[],(address,uint96))"
      | "queueWithdrawal(uint256[],address[],address[],uint256[],(address,uint96),bool)"
      | "queuedWithdrawals"
      | "removeFromWhitelist"
      | "renounceOwnership"
      | "setMinStakeAmount"
      | "setStakingSlash"
      | "setTssGroupManager"
      | "slashQueuedWithdrawal"
      | "slashShares"
      | "stakingSlash"
      | "startQueuedWithdrawalWaitingPeriod(bytes32,address,uint32)"
      | "startQueuedWithdrawalWaitingPeriod(bytes32,uint32)"
      | "transferOwnership"
      | "tssGroupManager"
      | "undelegate"
      | "whitelist"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "DEPOSIT_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "DOMAIN_SEPARATOR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "DOMAIN_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "REASONABLE_STAKES_UPDATE_PERIOD",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "WITHDRAWAL_WAITING_PERIOD",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "addToWhitelist",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateWithdrawalRoot",
    values: [IDelegationManager.QueuedWithdrawalStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "canCompleteQueuedWithdrawal",
    values: [IDelegationManager.QueuedWithdrawalStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "completeQueuedWithdrawal((address[],address[],uint256[],address,(address,uint96),address),bool)",
    values: [IDelegationManager.QueuedWithdrawalStruct, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "completeQueuedWithdrawal(address,(address[],address[],uint256[],address,(address,uint96),address),bool)",
    values: [
      PromiseOrValue<string>,
      IDelegationManager.QueuedWithdrawalStruct,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "delegation",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "delegationSlasher",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "depositInto(address,address,uint256,address)",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositInto(address,address,uint256)",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getDelegationShares",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getDeposits",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getWithdrawNonce",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "initializeT",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "investorDelegationLength",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "investorDelegationShares",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "investorDelegations",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isCanOperator",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "minStakeAmount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nonces",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "numWithdrawalsQueued",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "queueWithdrawal(address,uint256[],address[],address[],uint256[],(address,uint96))",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<string>[],
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      IDelegationManager.WithdrawerAndNonceStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "queueWithdrawal(uint256[],address[],address[],uint256[],(address,uint96),bool)",
    values: [
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<string>[],
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      IDelegationManager.WithdrawerAndNonceStruct,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "queuedWithdrawals",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeFromWhitelist",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setMinStakeAmount",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setStakingSlash",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setTssGroupManager",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "slashQueuedWithdrawal",
    values: [PromiseOrValue<string>, IDelegationManager.QueuedWithdrawalStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "slashShares",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>[],
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "stakingSlash",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "startQueuedWithdrawalWaitingPeriod(bytes32,address,uint32)",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "startQueuedWithdrawalWaitingPeriod(bytes32,uint32)",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "tssGroupManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "undelegate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "whitelist",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(
    functionFragment: "DEPOSIT_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "DOMAIN_SEPARATOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "DOMAIN_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "REASONABLE_STAKES_UPDATE_PERIOD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "WITHDRAWAL_WAITING_PERIOD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addToWhitelist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateWithdrawalRoot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canCompleteQueuedWithdrawal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "completeQueuedWithdrawal((address[],address[],uint256[],address,(address,uint96),address),bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "completeQueuedWithdrawal(address,(address[],address[],uint256[],address,(address,uint96),address),bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "delegation", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "delegationSlasher",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositInto(address,address,uint256,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositInto(address,address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDelegationShares",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDeposits",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getWithdrawNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "initializeT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "investorDelegationLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "investorDelegationShares",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "investorDelegations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isCanOperator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minStakeAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "numWithdrawalsQueued",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "queueWithdrawal(address,uint256[],address[],address[],uint256[],(address,uint96))",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "queueWithdrawal(uint256[],address[],address[],uint256[],(address,uint96),bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "queuedWithdrawals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeFromWhitelist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMinStakeAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setStakingSlash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTssGroupManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "slashQueuedWithdrawal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "slashShares",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stakingSlash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startQueuedWithdrawalWaitingPeriod(bytes32,address,uint32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startQueuedWithdrawalWaitingPeriod(bytes32,uint32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tssGroupManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "undelegate", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "whitelist", data: BytesLike): Result;

  events: {
    "Initialized(uint8)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "Paused(address)": EventFragment;
    "Unpaused(address)": EventFragment;
    "WithdrawalCompleted(address,address,bytes32)": EventFragment;
    "WithdrawalQueued(address,address,address,bytes32)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WithdrawalCompleted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WithdrawalQueued"): EventFragment;
}

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface WithdrawalCompletedEventObject {
  depositor: string;
  withdrawer: string;
  withdrawalRoot: string;
}
export type WithdrawalCompletedEvent = TypedEvent<
  [string, string, string],
  WithdrawalCompletedEventObject
>;

export type WithdrawalCompletedEventFilter =
  TypedEventFilter<WithdrawalCompletedEvent>;

export interface WithdrawalQueuedEventObject {
  depositor: string;
  withdrawer: string;
  delegatedAddress: string;
  withdrawalRoot: string;
}
export type WithdrawalQueuedEvent = TypedEvent<
  [string, string, string, string],
  WithdrawalQueuedEventObject
>;

export type WithdrawalQueuedEventFilter =
  TypedEventFilter<WithdrawalQueuedEvent>;

export interface TssDelegationManager extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: TssDelegationManagerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DEPOSIT_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;

    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    REASONABLE_STAKES_UPDATE_PERIOD(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    WITHDRAWAL_WAITING_PERIOD(overrides?: CallOverrides): Promise<[number]>;

    addToWhitelist(
      toAddAddresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    calculateWithdrawalRoot(
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      overrides?: CallOverrides
    ): Promise<[string]>;

    canCompleteQueuedWithdrawal(
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    "completeQueuedWithdrawal((address[],address[],uint256[],address,(address,uint96),address),bool)"(
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      receiveAsTokens: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "completeQueuedWithdrawal(address,(address[],address[],uint256[],address,(address,uint96),address),bool)"(
      sender: PromiseOrValue<string>,
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      receiveAsTokens: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    delegation(overrides?: CallOverrides): Promise<[string]>;

    delegationSlasher(overrides?: CallOverrides): Promise<[string]>;

    "depositInto(address,address,uint256,address)"(
      delegationShare: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "depositInto(address,address,uint256)"(
      delegationShare: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getDelegationShares(
      staker: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getDeposits(
      depositor: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], BigNumber[]]>;

    getWithdrawNonce(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    initialize(
      initialOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initializeT(
      _stakingSlashing: PromiseOrValue<string>,
      _tssGroupManager: PromiseOrValue<string>,
      _minStakeAmount: PromiseOrValue<BigNumberish>,
      initialOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    investorDelegationLength(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    investorDelegationShares(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    investorDelegations(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    isCanOperator(
      _addr: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    minStakeAmount(overrides?: CallOverrides): Promise<[BigNumber]>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    numWithdrawalsQueued(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    "queueWithdrawal(address,uint256[],address[],address[],uint256[],(address,uint96))"(
      sender: PromiseOrValue<string>,
      delegationIndexes: PromiseOrValue<BigNumberish>[],
      delegationShares: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      withdrawerAndNonce: IDelegationManager.WithdrawerAndNonceStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "queueWithdrawal(uint256[],address[],address[],uint256[],(address,uint96),bool)"(
      delegationIndexes: PromiseOrValue<BigNumberish>[],
      delegationShares: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      withdrawerAndNonce: IDelegationManager.WithdrawerAndNonceStruct,
      undelegateIfPossible: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    queuedWithdrawals(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [number, number, string] & {
        initTimestamp: number;
        unlockTimestamp: number;
        withdrawer: string;
      }
    >;

    removeFromWhitelist(
      toRemoveAddresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMinStakeAmount(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setStakingSlash(
      _address: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTssGroupManager(
      _addr: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    slashQueuedWithdrawal(
      recipient: PromiseOrValue<string>,
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    slashShares(
      slashedAddress: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      delegationShares: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      delegationIndexes: PromiseOrValue<BigNumberish>[],
      shareAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stakingSlash(overrides?: CallOverrides): Promise<[string]>;

    "startQueuedWithdrawalWaitingPeriod(bytes32,address,uint32)"(
      withdrawalRoot: PromiseOrValue<BytesLike>,
      sender: PromiseOrValue<string>,
      stakeInactiveAfter: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "startQueuedWithdrawalWaitingPeriod(bytes32,uint32)"(
      withdrawalRoot: PromiseOrValue<BytesLike>,
      stakeInactiveAfter: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    tssGroupManager(overrides?: CallOverrides): Promise<[string]>;

    undelegate(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    whitelist(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;
  };

  DEPOSIT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

  DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  REASONABLE_STAKES_UPDATE_PERIOD(
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  WITHDRAWAL_WAITING_PERIOD(overrides?: CallOverrides): Promise<number>;

  addToWhitelist(
    toAddAddresses: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  calculateWithdrawalRoot(
    queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
    overrides?: CallOverrides
  ): Promise<string>;

  canCompleteQueuedWithdrawal(
    queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "completeQueuedWithdrawal((address[],address[],uint256[],address,(address,uint96),address),bool)"(
    queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
    receiveAsTokens: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "completeQueuedWithdrawal(address,(address[],address[],uint256[],address,(address,uint96),address),bool)"(
    sender: PromiseOrValue<string>,
    queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
    receiveAsTokens: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  delegation(overrides?: CallOverrides): Promise<string>;

  delegationSlasher(overrides?: CallOverrides): Promise<string>;

  "depositInto(address,address,uint256,address)"(
    delegationShare: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    sender: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "depositInto(address,address,uint256)"(
    delegationShare: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getDelegationShares(
    staker: PromiseOrValue<string>,
    delegationShare: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getDeposits(
    depositor: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[string[], BigNumber[]]>;

  getWithdrawNonce(
    staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  initialize(
    initialOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initializeT(
    _stakingSlashing: PromiseOrValue<string>,
    _tssGroupManager: PromiseOrValue<string>,
    _minStakeAmount: PromiseOrValue<BigNumberish>,
    initialOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  investorDelegationLength(
    staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  investorDelegationShares(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  investorDelegations(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  isCanOperator(
    _addr: PromiseOrValue<string>,
    delegationShare: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  minStakeAmount(overrides?: CallOverrides): Promise<BigNumber>;

  nonces(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  numWithdrawalsQueued(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  "queueWithdrawal(address,uint256[],address[],address[],uint256[],(address,uint96))"(
    sender: PromiseOrValue<string>,
    delegationIndexes: PromiseOrValue<BigNumberish>[],
    delegationShares: PromiseOrValue<string>[],
    tokens: PromiseOrValue<string>[],
    shares: PromiseOrValue<BigNumberish>[],
    withdrawerAndNonce: IDelegationManager.WithdrawerAndNonceStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "queueWithdrawal(uint256[],address[],address[],uint256[],(address,uint96),bool)"(
    delegationIndexes: PromiseOrValue<BigNumberish>[],
    delegationShares: PromiseOrValue<string>[],
    tokens: PromiseOrValue<string>[],
    shares: PromiseOrValue<BigNumberish>[],
    withdrawerAndNonce: IDelegationManager.WithdrawerAndNonceStruct,
    undelegateIfPossible: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  queuedWithdrawals(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<
    [number, number, string] & {
      initTimestamp: number;
      unlockTimestamp: number;
      withdrawer: string;
    }
  >;

  removeFromWhitelist(
    toRemoveAddresses: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMinStakeAmount(
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setStakingSlash(
    _address: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTssGroupManager(
    _addr: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  slashQueuedWithdrawal(
    recipient: PromiseOrValue<string>,
    queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  slashShares(
    slashedAddress: PromiseOrValue<string>,
    recipient: PromiseOrValue<string>,
    delegationShares: PromiseOrValue<string>[],
    tokens: PromiseOrValue<string>[],
    delegationIndexes: PromiseOrValue<BigNumberish>[],
    shareAmounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stakingSlash(overrides?: CallOverrides): Promise<string>;

  "startQueuedWithdrawalWaitingPeriod(bytes32,address,uint32)"(
    withdrawalRoot: PromiseOrValue<BytesLike>,
    sender: PromiseOrValue<string>,
    stakeInactiveAfter: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "startQueuedWithdrawalWaitingPeriod(bytes32,uint32)"(
    withdrawalRoot: PromiseOrValue<BytesLike>,
    stakeInactiveAfter: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  tssGroupManager(overrides?: CallOverrides): Promise<string>;

  undelegate(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  whitelist(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    DEPOSIT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    REASONABLE_STAKES_UPDATE_PERIOD(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    WITHDRAWAL_WAITING_PERIOD(overrides?: CallOverrides): Promise<number>;

    addToWhitelist(
      toAddAddresses: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    calculateWithdrawalRoot(
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      overrides?: CallOverrides
    ): Promise<string>;

    canCompleteQueuedWithdrawal(
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "completeQueuedWithdrawal((address[],address[],uint256[],address,(address,uint96),address),bool)"(
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      receiveAsTokens: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    "completeQueuedWithdrawal(address,(address[],address[],uint256[],address,(address,uint96),address),bool)"(
      sender: PromiseOrValue<string>,
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      receiveAsTokens: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    delegation(overrides?: CallOverrides): Promise<string>;

    delegationSlasher(overrides?: CallOverrides): Promise<string>;

    "depositInto(address,address,uint256,address)"(
      delegationShare: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "depositInto(address,address,uint256)"(
      delegationShare: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDelegationShares(
      staker: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDeposits(
      depositor: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], BigNumber[]]>;

    getWithdrawNonce(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      initialOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    initializeT(
      _stakingSlashing: PromiseOrValue<string>,
      _tssGroupManager: PromiseOrValue<string>,
      _minStakeAmount: PromiseOrValue<BigNumberish>,
      initialOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    investorDelegationLength(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    investorDelegationShares(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    investorDelegations(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    isCanOperator(
      _addr: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    minStakeAmount(overrides?: CallOverrides): Promise<BigNumber>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    numWithdrawalsQueued(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    "queueWithdrawal(address,uint256[],address[],address[],uint256[],(address,uint96))"(
      sender: PromiseOrValue<string>,
      delegationIndexes: PromiseOrValue<BigNumberish>[],
      delegationShares: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      withdrawerAndNonce: IDelegationManager.WithdrawerAndNonceStruct,
      overrides?: CallOverrides
    ): Promise<string>;

    "queueWithdrawal(uint256[],address[],address[],uint256[],(address,uint96),bool)"(
      delegationIndexes: PromiseOrValue<BigNumberish>[],
      delegationShares: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      withdrawerAndNonce: IDelegationManager.WithdrawerAndNonceStruct,
      undelegateIfPossible: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<string>;

    queuedWithdrawals(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [number, number, string] & {
        initTimestamp: number;
        unlockTimestamp: number;
        withdrawer: string;
      }
    >;

    removeFromWhitelist(
      toRemoveAddresses: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    setMinStakeAmount(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setStakingSlash(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setTssGroupManager(
      _addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    slashQueuedWithdrawal(
      recipient: PromiseOrValue<string>,
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    slashShares(
      slashedAddress: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      delegationShares: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      delegationIndexes: PromiseOrValue<BigNumberish>[],
      shareAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    stakingSlash(overrides?: CallOverrides): Promise<string>;

    "startQueuedWithdrawalWaitingPeriod(bytes32,address,uint32)"(
      withdrawalRoot: PromiseOrValue<BytesLike>,
      sender: PromiseOrValue<string>,
      stakeInactiveAfter: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    "startQueuedWithdrawalWaitingPeriod(bytes32,uint32)"(
      withdrawalRoot: PromiseOrValue<BytesLike>,
      stakeInactiveAfter: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    tssGroupManager(overrides?: CallOverrides): Promise<string>;

    undelegate(overrides?: CallOverrides): Promise<void>;

    whitelist(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "Paused(address)"(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    "Unpaused(address)"(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;

    "WithdrawalCompleted(address,address,bytes32)"(
      depositor?: PromiseOrValue<string> | null,
      withdrawer?: PromiseOrValue<string> | null,
      withdrawalRoot?: null
    ): WithdrawalCompletedEventFilter;
    WithdrawalCompleted(
      depositor?: PromiseOrValue<string> | null,
      withdrawer?: PromiseOrValue<string> | null,
      withdrawalRoot?: null
    ): WithdrawalCompletedEventFilter;

    "WithdrawalQueued(address,address,address,bytes32)"(
      depositor?: PromiseOrValue<string> | null,
      withdrawer?: PromiseOrValue<string> | null,
      delegatedAddress?: PromiseOrValue<string> | null,
      withdrawalRoot?: null
    ): WithdrawalQueuedEventFilter;
    WithdrawalQueued(
      depositor?: PromiseOrValue<string> | null,
      withdrawer?: PromiseOrValue<string> | null,
      delegatedAddress?: PromiseOrValue<string> | null,
      withdrawalRoot?: null
    ): WithdrawalQueuedEventFilter;
  };

  estimateGas: {
    DEPOSIT_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;

    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    REASONABLE_STAKES_UPDATE_PERIOD(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    WITHDRAWAL_WAITING_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

    addToWhitelist(
      toAddAddresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    calculateWithdrawalRoot(
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    canCompleteQueuedWithdrawal(
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "completeQueuedWithdrawal((address[],address[],uint256[],address,(address,uint96),address),bool)"(
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      receiveAsTokens: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "completeQueuedWithdrawal(address,(address[],address[],uint256[],address,(address,uint96),address),bool)"(
      sender: PromiseOrValue<string>,
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      receiveAsTokens: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    delegation(overrides?: CallOverrides): Promise<BigNumber>;

    delegationSlasher(overrides?: CallOverrides): Promise<BigNumber>;

    "depositInto(address,address,uint256,address)"(
      delegationShare: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "depositInto(address,address,uint256)"(
      delegationShare: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getDelegationShares(
      staker: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDeposits(
      depositor: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getWithdrawNonce(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      initialOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initializeT(
      _stakingSlashing: PromiseOrValue<string>,
      _tssGroupManager: PromiseOrValue<string>,
      _minStakeAmount: PromiseOrValue<BigNumberish>,
      initialOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    investorDelegationLength(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    investorDelegationShares(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    investorDelegations(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isCanOperator(
      _addr: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    minStakeAmount(overrides?: CallOverrides): Promise<BigNumber>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    numWithdrawalsQueued(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    "queueWithdrawal(address,uint256[],address[],address[],uint256[],(address,uint96))"(
      sender: PromiseOrValue<string>,
      delegationIndexes: PromiseOrValue<BigNumberish>[],
      delegationShares: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      withdrawerAndNonce: IDelegationManager.WithdrawerAndNonceStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "queueWithdrawal(uint256[],address[],address[],uint256[],(address,uint96),bool)"(
      delegationIndexes: PromiseOrValue<BigNumberish>[],
      delegationShares: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      withdrawerAndNonce: IDelegationManager.WithdrawerAndNonceStruct,
      undelegateIfPossible: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    queuedWithdrawals(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    removeFromWhitelist(
      toRemoveAddresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMinStakeAmount(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setStakingSlash(
      _address: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTssGroupManager(
      _addr: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    slashQueuedWithdrawal(
      recipient: PromiseOrValue<string>,
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    slashShares(
      slashedAddress: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      delegationShares: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      delegationIndexes: PromiseOrValue<BigNumberish>[],
      shareAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stakingSlash(overrides?: CallOverrides): Promise<BigNumber>;

    "startQueuedWithdrawalWaitingPeriod(bytes32,address,uint32)"(
      withdrawalRoot: PromiseOrValue<BytesLike>,
      sender: PromiseOrValue<string>,
      stakeInactiveAfter: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "startQueuedWithdrawalWaitingPeriod(bytes32,uint32)"(
      withdrawalRoot: PromiseOrValue<BytesLike>,
      stakeInactiveAfter: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    tssGroupManager(overrides?: CallOverrides): Promise<BigNumber>;

    undelegate(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    whitelist(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DEPOSIT_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    REASONABLE_STAKES_UPDATE_PERIOD(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    WITHDRAWAL_WAITING_PERIOD(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    addToWhitelist(
      toAddAddresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    calculateWithdrawalRoot(
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    canCompleteQueuedWithdrawal(
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "completeQueuedWithdrawal((address[],address[],uint256[],address,(address,uint96),address),bool)"(
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      receiveAsTokens: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "completeQueuedWithdrawal(address,(address[],address[],uint256[],address,(address,uint96),address),bool)"(
      sender: PromiseOrValue<string>,
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      receiveAsTokens: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    delegation(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    delegationSlasher(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "depositInto(address,address,uint256,address)"(
      delegationShare: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "depositInto(address,address,uint256)"(
      delegationShare: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getDelegationShares(
      staker: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDeposits(
      depositor: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getWithdrawNonce(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      initialOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initializeT(
      _stakingSlashing: PromiseOrValue<string>,
      _tssGroupManager: PromiseOrValue<string>,
      _minStakeAmount: PromiseOrValue<BigNumberish>,
      initialOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    investorDelegationLength(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    investorDelegationShares(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    investorDelegations(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isCanOperator(
      _addr: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    minStakeAmount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    numWithdrawalsQueued(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "queueWithdrawal(address,uint256[],address[],address[],uint256[],(address,uint96))"(
      sender: PromiseOrValue<string>,
      delegationIndexes: PromiseOrValue<BigNumberish>[],
      delegationShares: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      withdrawerAndNonce: IDelegationManager.WithdrawerAndNonceStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "queueWithdrawal(uint256[],address[],address[],uint256[],(address,uint96),bool)"(
      delegationIndexes: PromiseOrValue<BigNumberish>[],
      delegationShares: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      withdrawerAndNonce: IDelegationManager.WithdrawerAndNonceStruct,
      undelegateIfPossible: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    queuedWithdrawals(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    removeFromWhitelist(
      toRemoveAddresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMinStakeAmount(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setStakingSlash(
      _address: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTssGroupManager(
      _addr: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    slashQueuedWithdrawal(
      recipient: PromiseOrValue<string>,
      queuedWithdrawal: IDelegationManager.QueuedWithdrawalStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    slashShares(
      slashedAddress: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      delegationShares: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      delegationIndexes: PromiseOrValue<BigNumberish>[],
      shareAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stakingSlash(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "startQueuedWithdrawalWaitingPeriod(bytes32,address,uint32)"(
      withdrawalRoot: PromiseOrValue<BytesLike>,
      sender: PromiseOrValue<string>,
      stakeInactiveAfter: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "startQueuedWithdrawalWaitingPeriod(bytes32,uint32)"(
      withdrawalRoot: PromiseOrValue<BytesLike>,
      stakeInactiveAfter: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    tssGroupManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    undelegate(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    whitelist(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
