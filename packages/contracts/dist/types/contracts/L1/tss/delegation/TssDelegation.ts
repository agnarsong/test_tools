/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../../../common";

export interface TssDelegationInterface extends utils.Interface {
  functions: {
    "DELEGATION_TYPEHASH()": FunctionFragment;
    "DOMAIN_SEPARATOR()": FunctionFragment;
    "DOMAIN_TYPEHASH()": FunctionFragment;
    "addToWhitelist(address[])": FunctionFragment;
    "decreaseDelegatedShares(address,address,uint256)": FunctionFragment;
    "decreaseDelegatedShares(address,address[],uint256[])": FunctionFragment;
    "delegateTo(address,address)": FunctionFragment;
    "delegateTo(address)": FunctionFragment;
    "delegateToSignature(address,address,uint256,bytes32,bytes32)": FunctionFragment;
    "delegatedTo(address)": FunctionFragment;
    "delegationCallback(address)": FunctionFragment;
    "delegationManager()": FunctionFragment;
    "delegationStatus(address)": FunctionFragment;
    "increaseDelegatedShares(address,address,uint256)": FunctionFragment;
    "initialize(address)": FunctionFragment;
    "initializeT(address,address)": FunctionFragment;
    "isDelegated(address)": FunctionFragment;
    "isNotDelegated(address)": FunctionFragment;
    "isOperator(address)": FunctionFragment;
    "nonces(address)": FunctionFragment;
    "operatorShares(address,address)": FunctionFragment;
    "owner()": FunctionFragment;
    "pause()": FunctionFragment;
    "paused()": FunctionFragment;
    "registerAsOperator(address,address)": FunctionFragment;
    "registerAsOperator(address)": FunctionFragment;
    "removeFromWhitelist(address[])": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "setStakingSlash(address)": FunctionFragment;
    "stakingSlash()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "undelegate(address)": FunctionFragment;
    "unpause()": FunctionFragment;
    "whitelist(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "DELEGATION_TYPEHASH"
      | "DOMAIN_SEPARATOR"
      | "DOMAIN_TYPEHASH"
      | "addToWhitelist"
      | "decreaseDelegatedShares(address,address,uint256)"
      | "decreaseDelegatedShares(address,address[],uint256[])"
      | "delegateTo(address,address)"
      | "delegateTo(address)"
      | "delegateToSignature"
      | "delegatedTo"
      | "delegationCallback"
      | "delegationManager"
      | "delegationStatus"
      | "increaseDelegatedShares"
      | "initialize"
      | "initializeT"
      | "isDelegated"
      | "isNotDelegated"
      | "isOperator"
      | "nonces"
      | "operatorShares"
      | "owner"
      | "pause"
      | "paused"
      | "registerAsOperator(address,address)"
      | "registerAsOperator(address)"
      | "removeFromWhitelist"
      | "renounceOwnership"
      | "setStakingSlash"
      | "stakingSlash"
      | "transferOwnership"
      | "undelegate"
      | "unpause"
      | "whitelist"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "DELEGATION_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "DOMAIN_SEPARATOR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "DOMAIN_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "addToWhitelist",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "decreaseDelegatedShares(address,address,uint256)",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "decreaseDelegatedShares(address,address[],uint256[])",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "delegateTo(address,address)",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "delegateTo(address)",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "delegateToSignature",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "delegatedTo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "delegationCallback",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "delegationManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "delegationStatus",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "increaseDelegatedShares",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "initializeT",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isDelegated",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isNotDelegated",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isOperator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "nonces",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "operatorShares",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "pause", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "registerAsOperator(address,address)",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "registerAsOperator(address)",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeFromWhitelist",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setStakingSlash",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakingSlash",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "undelegate",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "whitelist",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(
    functionFragment: "DELEGATION_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "DOMAIN_SEPARATOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "DOMAIN_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addToWhitelist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "decreaseDelegatedShares(address,address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "decreaseDelegatedShares(address,address[],uint256[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "delegateTo(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "delegateTo(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "delegateToSignature",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "delegatedTo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "delegationCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "delegationManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "delegationStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "increaseDelegatedShares",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "initializeT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isDelegated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isNotDelegated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isOperator", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "operatorShares",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "registerAsOperator(address,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerAsOperator(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeFromWhitelist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setStakingSlash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stakingSlash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "undelegate", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "whitelist", data: BytesLike): Result;

  events: {
    "DecreaseDelegatedShares(address,address,uint256)": EventFragment;
    "DelegateTo(address,address)": EventFragment;
    "IncreaseDelegatedShares(address,address,uint256)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "OnDelegationReceivedCallFailure(address,bytes32)": EventFragment;
    "OnDelegationWithdrawnCallFailure(address,bytes32)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "Paused(address)": EventFragment;
    "RegisterOperator(address,address)": EventFragment;
    "Unpaused(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "DecreaseDelegatedShares"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DelegateTo"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "IncreaseDelegatedShares"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "OnDelegationReceivedCallFailure"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "OnDelegationWithdrawnCallFailure"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RegisterOperator"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
}

export interface DecreaseDelegatedSharesEventObject {
  delegatedShare: string;
  operator: string;
  share: BigNumber;
}
export type DecreaseDelegatedSharesEvent = TypedEvent<
  [string, string, BigNumber],
  DecreaseDelegatedSharesEventObject
>;

export type DecreaseDelegatedSharesEventFilter =
  TypedEventFilter<DecreaseDelegatedSharesEvent>;

export interface DelegateToEventObject {
  delegatior: string;
  operator: string;
}
export type DelegateToEvent = TypedEvent<
  [string, string],
  DelegateToEventObject
>;

export type DelegateToEventFilter = TypedEventFilter<DelegateToEvent>;

export interface IncreaseDelegatedSharesEventObject {
  delegatedShare: string;
  operator: string;
  share: BigNumber;
}
export type IncreaseDelegatedSharesEvent = TypedEvent<
  [string, string, BigNumber],
  IncreaseDelegatedSharesEventObject
>;

export type IncreaseDelegatedSharesEventFilter =
  TypedEventFilter<IncreaseDelegatedSharesEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface OnDelegationReceivedCallFailureEventObject {
  delegationTerms: string;
  returnData: string;
}
export type OnDelegationReceivedCallFailureEvent = TypedEvent<
  [string, string],
  OnDelegationReceivedCallFailureEventObject
>;

export type OnDelegationReceivedCallFailureEventFilter =
  TypedEventFilter<OnDelegationReceivedCallFailureEvent>;

export interface OnDelegationWithdrawnCallFailureEventObject {
  delegationTerms: string;
  returnData: string;
}
export type OnDelegationWithdrawnCallFailureEvent = TypedEvent<
  [string, string],
  OnDelegationWithdrawnCallFailureEventObject
>;

export type OnDelegationWithdrawnCallFailureEventFilter =
  TypedEventFilter<OnDelegationWithdrawnCallFailureEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface RegisterOperatorEventObject {
  delegationCallback: string;
  register: string;
}
export type RegisterOperatorEvent = TypedEvent<
  [string, string],
  RegisterOperatorEventObject
>;

export type RegisterOperatorEventFilter =
  TypedEventFilter<RegisterOperatorEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface TssDelegation extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: TssDelegationInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DELEGATION_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;

    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    addToWhitelist(
      toAddAddresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "decreaseDelegatedShares(address,address,uint256)"(
      staker: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "decreaseDelegatedShares(address,address[],uint256[])"(
      staker: PromiseOrValue<string>,
      strategies: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "delegateTo(address,address)"(
      operator: PromiseOrValue<string>,
      staker: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "delegateTo(address)"(
      operator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    delegateToSignature(
      staker: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      vs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    delegatedTo(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    delegationCallback(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    delegationManager(overrides?: CallOverrides): Promise<[string]>;

    delegationStatus(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    increaseDelegatedShares(
      staker: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initialize(
      initialOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initializeT(
      _stakingSlashing: PromiseOrValue<string>,
      initialOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isDelegated(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isNotDelegated(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isOperator(
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    operatorShares(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    "registerAsOperator(address,address)"(
      dt: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "registerAsOperator(address)"(
      dt: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeFromWhitelist(
      toRemoveAddresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setStakingSlash(
      _address: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stakingSlash(overrides?: CallOverrides): Promise<[string]>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    undelegate(
      staker: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    whitelist(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;
  };

  DELEGATION_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

  DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  addToWhitelist(
    toAddAddresses: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "decreaseDelegatedShares(address,address,uint256)"(
    staker: PromiseOrValue<string>,
    delegationShare: PromiseOrValue<string>,
    shares: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "decreaseDelegatedShares(address,address[],uint256[])"(
    staker: PromiseOrValue<string>,
    strategies: PromiseOrValue<string>[],
    shares: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "delegateTo(address,address)"(
    operator: PromiseOrValue<string>,
    staker: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "delegateTo(address)"(
    operator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  delegateToSignature(
    staker: PromiseOrValue<string>,
    operator: PromiseOrValue<string>,
    expiry: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    vs: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  delegatedTo(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  delegationCallback(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  delegationManager(overrides?: CallOverrides): Promise<string>;

  delegationStatus(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<number>;

  increaseDelegatedShares(
    staker: PromiseOrValue<string>,
    delegationShare: PromiseOrValue<string>,
    shares: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initialize(
    initialOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initializeT(
    _stakingSlashing: PromiseOrValue<string>,
    initialOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isDelegated(
    staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isNotDelegated(
    staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isOperator(
    operator: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  nonces(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  operatorShares(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  pause(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  "registerAsOperator(address,address)"(
    dt: PromiseOrValue<string>,
    sender: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "registerAsOperator(address)"(
    dt: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeFromWhitelist(
    toRemoveAddresses: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setStakingSlash(
    _address: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stakingSlash(overrides?: CallOverrides): Promise<string>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  undelegate(
    staker: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unpause(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  whitelist(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    DELEGATION_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    addToWhitelist(
      toAddAddresses: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    "decreaseDelegatedShares(address,address,uint256)"(
      staker: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    "decreaseDelegatedShares(address,address[],uint256[])"(
      staker: PromiseOrValue<string>,
      strategies: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    "delegateTo(address,address)"(
      operator: PromiseOrValue<string>,
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    "delegateTo(address)"(
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    delegateToSignature(
      staker: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      vs: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    delegatedTo(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    delegationCallback(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    delegationManager(overrides?: CallOverrides): Promise<string>;

    delegationStatus(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<number>;

    increaseDelegatedShares(
      staker: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    initialize(
      initialOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    initializeT(
      _stakingSlashing: PromiseOrValue<string>,
      initialOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    isDelegated(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isNotDelegated(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isOperator(
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    operatorShares(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    pause(overrides?: CallOverrides): Promise<void>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    "registerAsOperator(address,address)"(
      dt: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    "registerAsOperator(address)"(
      dt: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    removeFromWhitelist(
      toRemoveAddresses: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    setStakingSlash(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    stakingSlash(overrides?: CallOverrides): Promise<string>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    undelegate(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    unpause(overrides?: CallOverrides): Promise<void>;

    whitelist(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    "DecreaseDelegatedShares(address,address,uint256)"(
      delegatedShare?: null,
      operator?: null,
      share?: null
    ): DecreaseDelegatedSharesEventFilter;
    DecreaseDelegatedShares(
      delegatedShare?: null,
      operator?: null,
      share?: null
    ): DecreaseDelegatedSharesEventFilter;

    "DelegateTo(address,address)"(
      delegatior?: null,
      operator?: null
    ): DelegateToEventFilter;
    DelegateTo(delegatior?: null, operator?: null): DelegateToEventFilter;

    "IncreaseDelegatedShares(address,address,uint256)"(
      delegatedShare?: null,
      operator?: null,
      share?: null
    ): IncreaseDelegatedSharesEventFilter;
    IncreaseDelegatedShares(
      delegatedShare?: null,
      operator?: null,
      share?: null
    ): IncreaseDelegatedSharesEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "OnDelegationReceivedCallFailure(address,bytes32)"(
      delegationTerms?: PromiseOrValue<string> | null,
      returnData?: null
    ): OnDelegationReceivedCallFailureEventFilter;
    OnDelegationReceivedCallFailure(
      delegationTerms?: PromiseOrValue<string> | null,
      returnData?: null
    ): OnDelegationReceivedCallFailureEventFilter;

    "OnDelegationWithdrawnCallFailure(address,bytes32)"(
      delegationTerms?: PromiseOrValue<string> | null,
      returnData?: null
    ): OnDelegationWithdrawnCallFailureEventFilter;
    OnDelegationWithdrawnCallFailure(
      delegationTerms?: PromiseOrValue<string> | null,
      returnData?: null
    ): OnDelegationWithdrawnCallFailureEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "Paused(address)"(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    "RegisterOperator(address,address)"(
      delegationCallback?: null,
      register?: null
    ): RegisterOperatorEventFilter;
    RegisterOperator(
      delegationCallback?: null,
      register?: null
    ): RegisterOperatorEventFilter;

    "Unpaused(address)"(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;
  };

  estimateGas: {
    DELEGATION_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;

    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    addToWhitelist(
      toAddAddresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "decreaseDelegatedShares(address,address,uint256)"(
      staker: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "decreaseDelegatedShares(address,address[],uint256[])"(
      staker: PromiseOrValue<string>,
      strategies: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "delegateTo(address,address)"(
      operator: PromiseOrValue<string>,
      staker: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "delegateTo(address)"(
      operator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    delegateToSignature(
      staker: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      vs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    delegatedTo(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    delegationCallback(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    delegationManager(overrides?: CallOverrides): Promise<BigNumber>;

    delegationStatus(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    increaseDelegatedShares(
      staker: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initialize(
      initialOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initializeT(
      _stakingSlashing: PromiseOrValue<string>,
      initialOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isDelegated(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isNotDelegated(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isOperator(
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    operatorShares(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    "registerAsOperator(address,address)"(
      dt: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "registerAsOperator(address)"(
      dt: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeFromWhitelist(
      toRemoveAddresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setStakingSlash(
      _address: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stakingSlash(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    undelegate(
      staker: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    whitelist(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DELEGATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    addToWhitelist(
      toAddAddresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "decreaseDelegatedShares(address,address,uint256)"(
      staker: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "decreaseDelegatedShares(address,address[],uint256[])"(
      staker: PromiseOrValue<string>,
      strategies: PromiseOrValue<string>[],
      shares: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "delegateTo(address,address)"(
      operator: PromiseOrValue<string>,
      staker: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "delegateTo(address)"(
      operator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    delegateToSignature(
      staker: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      vs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    delegatedTo(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    delegationCallback(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    delegationManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    delegationStatus(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    increaseDelegatedShares(
      staker: PromiseOrValue<string>,
      delegationShare: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      initialOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initializeT(
      _stakingSlashing: PromiseOrValue<string>,
      initialOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isDelegated(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isNotDelegated(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isOperator(
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    operatorShares(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "registerAsOperator(address,address)"(
      dt: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "registerAsOperator(address)"(
      dt: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeFromWhitelist(
      toRemoveAddresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setStakingSlash(
      _address: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stakingSlash(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    undelegate(
      staker: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    whitelist(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
